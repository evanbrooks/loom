var hackySpring;

// Generated by CoffeeScript 1.7.1
(function() {
  var springAccelerationForState, springEvaluateState, springEvaluateStateWithDerivative, springIntegrateState,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  hackySpring = (function() {
    function SpringRK4Animator() {
      this.finished = __bind(this.finished, this);
    }

    SpringRK4Animator.prototype.setup = function(options) {
      this.options = {
        tension: 500,
        friction: 10,
        velocity: 0,
        tolerance: 1 / 10000,
        time: null
      };

      for (var k in options) this.options[k] = options[k];


      this._time = 0;
      this._value = 0;
      this._velocity = this.options.velocity;
      return this._stopSpring = false;
    };

    SpringRK4Animator.prototype.next = function(delta) {
      var finalVelocity, net1DVelocity, netFloat, netValueIsLow, netVelocityIsLow, stateAfter, stateBefore;
      if (this.finished()) {
        return 1;
      }
      this._time += delta;
      stateBefore = {};
      stateAfter = {};
      stateBefore.x = this._value - 1;
      stateBefore.v = this._velocity;
      stateBefore.tension = this.options.tension;
      stateBefore.friction = this.options.friction;
      stateAfter = springIntegrateState(stateBefore, delta);
      this._value = 1 + stateAfter.x;
      finalVelocity = stateAfter.v;
      netFloat = stateAfter.x;
      net1DVelocity = stateAfter.v;
      netValueIsLow = Math.abs(netFloat) < this.options.tolerance;
      netVelocityIsLow = Math.abs(net1DVelocity) < this.options.tolerance;
      this._stopSpring = netValueIsLow && netVelocityIsLow;
      this._velocity = finalVelocity;
      return this._value;
    };

    SpringRK4Animator.prototype.finished = function() {
      return this._stopSpring;
    };

    return SpringRK4Animator;

  })();

  springAccelerationForState = function(state) {
    return -state.tension * state.x - state.friction * state.v;
  };

  springEvaluateState = function(initialState) {
    var output;
    output = {};
    output.dx = initialState.v;
    output.dv = springAccelerationForState(initialState);
    return output;
  };

  springEvaluateStateWithDerivative = function(initialState, dt, derivative) {
    var output, state;
    state = {};
    state.x = initialState.x + derivative.dx * dt;
    state.v = initialState.v + derivative.dv * dt;
    state.tension = initialState.tension;
    state.friction = initialState.friction;
    output = {};
    output.dx = state.v;
    output.dv = springAccelerationForState(state);
    return output;
  };

  springIntegrateState = function(state, speed) {
    var a, b, c, d, dvdt, dxdt;
    a = springEvaluateState(state);
    b = springEvaluateStateWithDerivative(state, speed * 0.5, a);
    c = springEvaluateStateWithDerivative(state, speed * 0.5, b);
    d = springEvaluateStateWithDerivative(state, speed, c);
    dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx);
    dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
    state.x = state.x + dxdt * speed;
    state.v = state.v + dvdt * speed;
    return state;
  };

}).call(this);
